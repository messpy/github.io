<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tama Dot Cute (Egg -> Hatch)</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 16px; }
    .box { border: 1px solid #ccc; border-radius: 12px; padding: 12px; max-width: 960px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; align-items: center; }
    button { padding: 8px 12px; cursor: pointer; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    pre {
      margin-top: 12px;
      padding: 14px;
      border-radius: 12px;
      background: #f7f7f7;
      overflow: auto;
      line-height: 1.05;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 16px;
      white-space: pre;
    }
    .pill { padding: 2px 10px; border: 1px solid #ddd; border-radius: 999px; background: #fff; }
    .muted { color: #666; font-size: 12px; }
    .warn { border-color: #f5c542; background: #fff9e6; }
    .danger { border-color: #ff7a7a; background: #ffecec; }
  </style>
</head>
<body>
  <div class="box">
    <h1>たまごっち（卵→孵化→成長 / ローカル育成）</h1>
    <div class="muted">この端末のブラウザだけで育ちます（localStorage保存）。</div>

    <div class="row">
      <div class="pill">訪問: <b id="visits"></b></div>
      <div class="pill">滞在: <b id="watched"></b> 秒</div>
      <div class="pill">段階: <b id="phase"></b></div>
      <div class="pill">サイズ: <b id="size"></b></div>
      <div class="pill">状態: <b id="state"></b></div>
      <div class="pill">機嫌: <b id="happy"></b></div>
      <div class="pill">汚れ: <b id="dirty"></b></div>
      <div class="pill">満腹: <b id="full"></b></div>
      <div class="pill" id="alertPill" style="display:none;"><b id="alertText"></b></div>
    </div>

    <div class="row">
      <button id="warm">あたためる</button>
      <button id="feed">えさ</button>
      <button id="play">あそぶ</button>
      <button id="clean">そうじ</button>
      <button id="reset">リセット</button>
    </div>

    <pre id="screen"></pre>
    <div class="muted">タブが非表示の間は滞在カウント停止。</div>
  </div>

<script>
(() => {
  const KEY = "tama_dot_cute_state_v3";
  const SESSION_KEY = "tama_dot_cute_counted_session_v1";

  const nowMs = () => Date.now();
  const clamp = (n,a,b) => Math.max(a, Math.min(b, n));

  // ---- パラメータ
  const HATCH_WAIT_SEC = 60;    // あたため開始から孵化まで
  const FULL_MAX = 14;
  const FULL_WARN = 11;

  const FULL_DECAY_SEC = 18;
  const DIRTY_INC_SEC = 35;
  const HAPPY_DECAY_SEC = 25;

  // 孵化後のサイズ成長（滞在秒ベース）
  // 小: 0-89秒 / 中: 90-239秒 / 大: 240秒～
  const SIZE_SMALL_SEC = 0;
  const SIZE_MEDIUM_SEC = 90;
  const SIZE_LARGE_SEC = 240;

  // ---- phase
  // egg: 卵（未加温）
  // warming: あたため中（孵化待ち）
  // baby: 孵化直後（小）
  // live: 通常（サイズで見た目が変わる）
  function loadState(){
    const raw = localStorage.getItem(KEY);
    if (!raw) {
      return {
        createdAt: nowMs(),
        visits: 0,
        watchedSec: 0,

        phase: "egg",
        warmStartAt: 0,     // warming開始時刻(ms)
        hatchedAt: 0,       // 孵化時刻(ms)（サイズ計算用）
        alive: true,
        deadReason: "",

        full: 0,
        happy: 0,
        dirty: 0,

        feedCount: 0,
        playCount: 0,
        cleanCount: 0,

        anim: { mode: "idle", frame: 0, untilMs: 0 },
      };
    }
    try { return JSON.parse(raw); }
    catch {
      localStorage.removeItem(KEY);
      return loadState();
    }
  }
  function saveState(s){ localStorage.setItem(KEY, JSON.stringify(s)); }

  function calcPoints(s){
    if (!s.alive) return 0;
    const base = s.visits * 10 + Math.floor(s.watchedSec / 10);
    const care = s.feedCount * 2 + s.playCount * 3 + s.cleanCount * 2;
    const health = Math.max(0, (10 - s.dirty)) + s.happy;
    return Math.max(0, base + care + health);
  }
  function calcLevel(pt){
    if (pt >= 240) return 6;
    if (pt >= 170) return 5;
    if (pt >= 110) return 4;
    if (pt >= 60)  return 3;
    if (pt >= 25)  return 2;
    return 1;
  }

  function moodName(s){
    if (!s.alive) return "しぼう";
    if (s.phase === "egg") return "まだ卵";
    if (s.phase === "warming") return "あたため中";
    if (s.full >= FULL_WARN) return "くるしい";
    if (s.dirty >= 7) return "きたない";
    if (s.happy >= 8) return "るんるん";
    if (s.happy <= 2) return "しょんぼり";
    return "ふつう";
  }

  function phaseLabel(phase){
    if (phase === "egg") return "卵";
    if (phase === "warming") return "孵化待ち";
    if (phase === "baby") return "ひな";
    if (phase === "live") return "育成中";
    return phase;
  }

  function sizeLabel(s){
    if (s.phase === "egg" || s.phase === "warming") return "-";
    const ageSec = Math.max(0, Math.floor((nowMs() - s.hatchedAt) / 1000));
    if (ageSec >= SIZE_LARGE_SEC) return "大";
    if (ageSec >= SIZE_MEDIUM_SEC) return "中";
    return "小";
  }

  function eggProgress(s){
    if (s.phase !== "warming") return 0;
    const elapsed = Math.max(0, Math.floor((nowMs() - s.warmStartAt) / 1000));
    return clamp(elapsed / HATCH_WAIT_SEC, 0, 1);
  }

  // ---- ドット絵
  function eggSprite(s){
    const p = eggProgress(s);
    const bar = Math.floor(p * 10);
    const gauge = "■".repeat(bar).padEnd(10, "·");

    // ひび割れは進行度で増やす
    const crack1 = p > 0.33 ? "  /\\  " : "      ";
    const crack2 = p > 0.66 ? " /__\\ " : "      ";

    return [
      "      ____      ",
      "    .-    -.    ",
      "   /  .--.  \\   ",
      "  |  /    \\  |  ",
      `  |  |${crack1}|  |  `,
      `  |  |${crack2}|  |  `,
      "   \\  '--'  /   ",
      "    '-.__.-'    ",
      "",
      `  あたため: [${gauge}]`,
      `  残り: ${Math.max(0, HATCH_WAIT_SEC - Math.floor((nowMs() - (s.warmStartAt||nowMs()))/1000))} 秒`,
      "",
      "  ボタン: あたためる",
    ].join("\n");
  }

  function eyesMouth(mood){
    switch(mood){
      case "るんるん": return { eyes: "•  •", mouth: "ᴗ" , cheek:"˶"};
      case "しょんぼり": return { eyes: "•  •", mouth: "︵", cheek:" "};
      case "きたない": return { eyes: "•  •", mouth: "…", cheek:" "};
      case "くるしい": return { eyes: "•  •", mouth: "︵", cheek:"°"};
      case "しぼう": return { eyes: "×  ×", mouth: "︵", cheek:" "};
      default: return { eyes: "•  •", mouth: "ᴥ", cheek:"˶" };
    }
  }

  function badgeLine(s){
    const f = "■".repeat(clamp(s.full,0,14)).padEnd(14,"·");
    const h = "■".repeat(clamp(s.happy,0,10)).padEnd(10,"·");
    const d = "■".repeat(clamp(s.dirty,0,10)).padEnd(10,"·");
    return `FULL[${f}]  HAPPY[${h}]  DIRTY[${d}]`;
  }

  function spriteDead(){
    return [
      "            ",
      "   .-''''-. ",
      "  /  ×  × \\",
      " |    ︵    |",
      " |  .____.  |",
      "  \\________/ ",
      "    _||_     ",
      "   /____\\    ",
      "",
      "  しんだ…",
    ].join("\n");
  }

  function spritePet(size, lv, mood, s){
    if (!s.alive) return spriteDead();

    const em = eyesMouth(mood);
    const poop = "※".repeat(clamp(Math.floor(s.dirty/2),0,6));
    const food = "o".repeat(clamp(Math.floor(s.full/2),0,6));

    // サイズで見た目を変える（小→中→大）
    // 小: ちいさい、手足短い
    // 中: 標準
    // 大: ちょい横幅+装飾
    const deco =
      lv >= 6 ? "   ✧  ✦   " :
      lv >= 5 ? "    ✦     " :
      lv >= 4 ? "    ✧     " :
                "          ";

    if (size === "小") {
      return [
        "            ",
        deco,
        "   .-''-.   ",
        "  / .--.\\  ",
        ` | ( ${em.eyes} ) | `,
        ` |   ${em.cheek}${em.mouth}${em.cheek}   | `,
        "  \\ '~~' /  ",
        "   '.__.'   ",
        `  food:${food.padEnd(6,"·")} dirt:${poop.padEnd(6,"·")}`,
      ].join("\n");
    }

    if (size === "中") {
      return [
        deco,
        "   .-''''-.      ",
        "  /  .--.  \\     ",
        ` |  ( ${em.eyes} )  |    `,
        ` |     ${em.cheek}${em.mouth}${em.cheek}     |    `,
        " |   .----.   |  ",
        "  \\  '----'  /   ",
        "   '._    _.'    ",
        "      '---'      ",
        `   food:${food.padEnd(6,"·")}  dirt:${poop.padEnd(6,"·")}`,
      ].join("\n");
    }

    // 大
    const hat =
      lv >= 5 ? "   /^\\      " :
      lv >= 4 ? "   /\\       " :
                "            ";

    return [
      deco,
      hat,
      "  .-''''''''-.   ",
      " /  .------.  \\  ",
      `|  (  ${em.eyes}  )  | `,
      `|      ${em.cheek}${em.mouth}${em.cheek}      | `,
      "|   .--------.  |",
      "|  /  ____   \\ |",
      " \\ \\ '----'  / /",
      "  '._      _.'  ",
      "     '----'     ",
      `  food:${food.padEnd(6,"·")}  dirt:${poop.padEnd(6,"·")}`,
    ].join("\n");
  }

  // 遊びアニメ
  function spritePlayFrame(frame){
    const em = eyesMouth("るんるん");
    const hands = frame % 2 === 0 ? "/\\  /\\" : "\\/  \\/";
    const jump  = frame % 2 === 0 ? "   " : " ";
    return [
      "            ",
      `${jump} .-''''-.   `,
      `${jump}/  .--.  \\  `,
      `${jump}| ( ${em.eyes} ) |  `,
      `${jump}|   ${em.cheek}${em.mouth}${em.cheek}   |  `,
      `${jump}|  ${hands}  |  `,
      `${jump}\\  '----' /  `,
      `${jump} '._  _.'   `,
      `${jump}   '---'    `,
      "    ♪  ♪     ",
      "",
      "   あそぶ！   ",
    ].join("\n");
  }

  // えさ直後フラッシュ
  function spriteFeedFlash(frame){
    const munch = frame % 2 === 0 ? "もぐもぐ" : "もっもっ";
    return [
      "            ",
      "   .-''''-. ",
      "  /  .--.  \\",
      " |  ( •  • ) |",
      " |     ᴗ     |",
      " |   (___)   |",
      "  \\  '---'  / ",
      "   '._  _.'   ",
      "      '---'   ",
      "",
      `   ${munch}…`,
    ].join("\n");
  }

  function computeAlert(s){
    if (!s.alive) return { show:true, level:"danger", text:`死亡: ${s.deadReason || "不明"}` };
    if (s.phase === "egg") return { show:true, level:"warn", text:"卵: あたためると孵化準備開始" };
    if (s.phase === "warming") return { show:true, level:"warn", text:"孵化待ち: 1分で孵化" };
    if (s.full >= FULL_WARN) return { show:true, level:"danger", text:"警告: えさ過多で危険" };
    if (s.dirty >= 7) return { show:true, level:"warn", text:"注意: よごれが多い" };
    if (s.happy <= 2) return { show:true, level:"warn", text:"注意: さみしそう" };
    return { show:false, level:"", text:"" };
  }

  // ---- UI
  const elVisits  = document.getElementById("visits");
  const elWatched = document.getElementById("watched");
  const elPhase   = document.getElementById("phase");
  const elSize    = document.getElementById("size");
  const elLv      = document.getElementById("lv");
  const elState   = document.getElementById("state");
  const elHappy   = document.getElementById("happy");
  const elDirty   = document.getElementById("dirty");
  const elFull    = document.getElementById("full");
  const elScreen  = document.getElementById("screen");
  const elAlertPill = document.getElementById("alertPill");
  const elAlertText = document.getElementById("alertText");

  const btnWarm  = document.getElementById("warm");
  const btnFeed  = document.getElementById("feed");
  const btnPlay  = document.getElementById("play");
  const btnClean = document.getElementById("clean");
  const btnReset = document.getElementById("reset");

  let state = loadState();

  // 訪問：1セッション1回
  if (!sessionStorage.getItem(SESSION_KEY)) {
    state.visits += 1;
    sessionStorage.setItem(SESSION_KEY, "1");
    saveState(state);
  }

  function checkDeath(){
    if (!state.alive) return;
    if (state.full > FULL_MAX) {
      state.alive = false;
      state.deadReason = "えさを食べすぎた";
      state.anim = { mode:"dead", frame:0, untilMs:0 };
    }
  }

  function startAnim(mode, durationMs){
    state.anim.mode = mode;
    state.anim.frame = 0;
    state.anim.untilMs = nowMs() + durationMs;
  }

  function tryHatch(){
    if (state.phase !== "warming") return;
    const elapsed = Math.floor((nowMs() - state.warmStartAt) / 1000);
    if (elapsed >= HATCH_WAIT_SEC) {
      state.phase = "baby";
      state.hatchedAt = nowMs();
      // 生まれたては小さく・ステータス控えめ
      state.alive = true;
      state.deadReason = "";
      state.full = 3;
      state.happy = 3;
      state.dirty = 0;
      startAnim("feed", 800); // かわいく演出（もぐもぐ風）を流用
      // baby状態はすぐliveへ（見た目は小で）
      state.phase = "live";
    }
  }

  // タイマー（表示中だけ）
  let timer = null;
  function startTimer(){
    if (timer) return;
    timer = setInterval(() => {
      // 卵/孵化待ちも滞在カウントは回す（成長に使ってもOK）
      state.watchedSec += 1;

      // warmingなら孵化判定
      if (state.phase === "warming") tryHatch();

      // 生きてる時だけ自然変化
      if (state.alive && (state.phase === "live")) {
        if (state.watchedSec % FULL_DECAY_SEC === 0) state.full = Math.max(0, state.full - 1);
        if (state.watchedSec % DIRTY_INC_SEC === 0) state.dirty += 1;
        if (state.watchedSec % HAPPY_DECAY_SEC === 0 && state.happy > 0) state.happy -= 1;
      }

      // アニメ更新
      if (state.anim.mode !== "idle") {
        if (nowMs() >= state.anim.untilMs) {
          state.anim = { mode:"idle", frame:0, untilMs:0 };
        } else {
          state.anim.frame += 1;
        }
      }

      checkDeath();
      saveState(state);
      render();
    }, 200);
  }

  function stopTimer(){
    if (!timer) return;
    clearInterval(timer);
    timer = null;
  }

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopTimer();
    else startTimer();
  });

  // ボタン
  btnWarm.addEventListener("click", () => {
    if (!state.alive) return;

    if (state.phase === "egg") {
      state.phase = "warming";
      state.warmStartAt = nowMs();
      saveState(state);
      render();
      return;
    }

    // warming中は押しても加速しない（チート防止）
    // live以降は無効
  });

  btnFeed.addEventListener("click", () => {
    if (!state.alive) return;
    if (state.phase !== "live") return;

    state.feedCount += 1;
    state.full += 2;
    state.happy += 1;
    state.dirty += 1;

    startAnim("feed", 1200);
    checkDeath();
    saveState(state);
    render();
  });

  btnPlay.addEventListener("click", () => {
    if (!state.alive) return;
    if (state.phase !== "live") return;

    state.playCount += 1;
    state.happy += 3;
    state.full = Math.max(0, state.full - 1);
    state.dirty += 1;

    startAnim("play", 2600);
    saveState(state);
    render();
  });

  btnClean.addEventListener("click", () => {
    if (!state.alive) return;
    if (state.phase !== "live") return;

    state.cleanCount += 1;
    state.dirty = Math.max(0, state.dirty - 3);
    state.happy += 1;

    saveState(state);
    render();
  });

  btnReset.addEventListener("click", () => {
    localStorage.removeItem(KEY);
    sessionStorage.removeItem(SESSION_KEY);
    state = loadState();
    saveState(state);
    render();
  });

  function render(){
    // 上限カット
    state.happy = clamp(state.happy, 0, 10);
    state.dirty = clamp(state.dirty, 0, 10);
    state.full  = clamp(state.full, 0, 99);

    const pt = calcPoints(state);
    const lv = calcLevel(pt);
    const mood = moodName(state);
    const size = sizeLabel(state);

    elVisits.textContent = String(state.visits);
    elWatched.textContent = String(state.watchedSec);
    elPhase.textContent = phaseLabel(state.phase);
    elSize.textContent = size;
    elLv.textContent = String(lv);
    elState.textContent = mood;
    elHappy.textContent = String(state.happy);
    elDirty.textContent = String(state.dirty);
    elFull.textContent = String(state.full);

    const alert = computeAlert(state);
    if (alert.show) {
      elAlertPill.style.display = "inline-block";
      elAlertText.textContent = alert.text;
      elAlertPill.classList.remove("warn","danger");
      if (alert.level) elAlertPill.classList.add(alert.level);
    } else {
      elAlertPill.style.display = "none";
    }

    // ボタン可否
    // 卵→warmingはwarmのみ、孵化後は世話系有効
    btnWarm.disabled  = (!state.alive) || (state.phase !== "egg");
    const canCare = state.alive && (state.phase === "live");
    btnFeed.disabled  = !canCare;
    btnPlay.disabled  = !canCare;
    btnClean.disabled = !canCare;

    // スプライト
    let sprite = "";
    if (state.phase === "egg" || state.phase === "warming") {
      sprite = eggSprite(state);
    } else if (!state.alive) {
      sprite = spriteDead();
    } else if (state.anim.mode === "play") {
      sprite = spritePlayFrame(state.anim.frame);
    } else if (state.anim.mode === "feed") {
      sprite = spriteFeedFlash(state.anim.frame);
    } else {
      sprite = spritePet(size, lv, mood, state);
    }

    elScreen.textContent =
      sprite +
      "\n\n" +
      (state.phase === "live" ? (badgeLine(state) + "\n") : "") +
      `pt=${pt} feed=${state.feedCount} play=${state.playCount} clean=${state.cleanCount}` +
      (!state.alive ? `\n理由: ${state.deadReason}` : "");
  }

  startTimer();
  render();
})();
</script>
</body>
</html>
